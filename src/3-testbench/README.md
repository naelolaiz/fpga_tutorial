#  Example on how to create a testbench for simulations
Example of testbench of a top-level entity using a single one-time-shot timer
# TOC
1. [DUT top-level diagram](#dut-diagram) 
2. [How the simulation looks](#questa-simulation)
3. [Testbench code](#explanation-of-the-testbench-code)
## DUT top-level diagram
Auto-generated by CI jobs, using https://github.com/naelolaiz/hdltools).

![top-level timer diagram](doc/toplevel_timer.svg)

 ## Questa Simulation
 * Loop with repetitive signal
  ![Questa simulation](doc/Screenshot_simulation.png)
 * Simplified signal
  ![Questa simulation](doc/Screenshot_simulation_simplified_signal.png)
## Explanation of the testbench code
 * for the testbench we use a portless entity 
```
-- test bench level entity
entity toplevel_timer_tb is
end;
```
 * we use signals to check states from the simulator environment. In the architecture, we declare:
``` 
 -- signals for inputs
  signal sClock50Mhz         : std_logic := '0';
  signal sButtonTimerEnabled : std_logic := '1';
 -- signals for outputs
  signal sOutLed             : std_logic ; 
```
 * in this example we also use an extra boolean signal to stop the simulation
```
  signal sSimulationDone : boolean := false;
```
* then we instantiate the entity we want to test
```
DUT : entity work.toplevel_timer(logic)
   generic map (CYCLES_FROM_TRIGGER_TO_SET_OUTPUT => CYCLES_FROM_TRIGGER_TO_SET_OUTPUT)
   port map (inClock50Mhz => sClock50Mhz,
             inNoReset    => sButtonTimerEnabled, 
             outLed       => sOutLed);
```
* then generate the input signals
  * the clock, using an assignment
```
sClock50Mhz <= not sClock50Mhz after CYCLE_PERIOD / 2 when not sSimulationDone;
``` 
  * and the input button simulation, using a process
```
generatePressedButton : process 
begin
  sButtonTimerEnabled <= '0';
  wait for BUTTON_LOW_TIME;
  sButtonTimerEnabled <= '1';
  wait for BUTTON_HIGH_TIME_INCLUDING_TRIGGER;
  sButtonTimerEnabled <= '0';
  wait for BUTTON_LOW_TIME;
  sButtonTimerEnabled <= '1';
  wait for BUTTON_HIGH_TIME_BEFORE_TRIGGER;
  sButtonTimerEnabled <= '0';
  sSimulationDone <= true;
  wait; -- blocks here
end process;
```
 * then we create processes for our tests
   * we expect HIGH-IMPEDANCE in the timer output as soon as the reset is HIGH (after the propagation time)
```
validateTimerHighImpedanceOutputOnReset : process 
begin
  wait until sButtonTimerEnabled = '0';
  wait for MIN_DELTA; -- wait for the signal to be propagated
  assert (sOutLed = 'Z')
    report "Timer output not Z when disabled (reset on)" severity error;
end process;
```
   * we expect a LOW in the timer output the next rising edge of the clock after the timer is enabled (reset is LOW) (after the propagation time)
```
validateOutputLowOnStartTimer : process 
begin
  wait until rising_edge(sButtonTimerEnabled);
  wait until rising_edge(sClock50Mhz);
  wait for MIN_DELTA; -- wait for the signal to be propagated
  assert (sOutLed = '0')
    report "Timer output not 0 after a fresh reset" severity error;
end process;
```
   * we expect the timer output to be HIGH after TIMER_TIME_FOR_TRIGGER (and propagation time) has passed since the timer output was set low after enabled
```
  validateOutputHighAfterTimerDone : process
   -- expected time for the output to be 1 (until high impedance)
    constant cExpectedTimeForHighIncludingTrigger : time := BUTTON_HIGH_TIME_INCLUDING_TRIGGER - (TIMER_TIME_FOR_TRIGGER + CYCLE_PERIOD);
   -- used to measure timer LOW time
    variable vTimestampLastLow    : time := 0 ns;
   -- used to measure timer HIGH time
    variable vTimestampLastHigh   : time := 0 ns;
  begin
    wait until sOutLed = '0';
    vTimestampLastLow := now; -- to check timing in low
    wait until rising_edge(sClock50Mhz);
    wait until sOutLed = '1';
    vTimestampLastHigh := now; -- to check timing in high
   -- check that the timer was triggered on time
    assert (abs((now - vTimestampLastLow) - TIMER_TIME_FOR_TRIGGER) < MIN_DELTA)
      report "Timer output not 1 after timeout period" severity error;
   -- check that the output is still 1 after four clocks
    for counter in 1 to 4 loop
       wait until rising_edge(sClock50Mhz);
       assert (sOutLed = '1')
         report "Timer output not kept 1 after timeout period" severity error;
     end loop;
   -- check that is still high until it changes to high impedance
    wait until sOutLed = 'Z';
    assert (abs((now - vTimestampLastHigh) - cExpectedTimeForHighIncludingTrigger) < MIN_DELTA + (CYCLE_PERIOD / 2)) -- we have half a cycle of uncertainty
      report "Error4 : timer output not 1 long enough" severity error;
  end process;
 ```
